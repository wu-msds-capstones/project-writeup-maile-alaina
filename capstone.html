<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Capstone Project: Evaluating AI Accuracy for Telehealth Diagnosis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="capstone_files/libs/clipboard/clipboard.min.js"></script>
<script src="capstone_files/libs/quarto-html/quarto.js"></script>
<script src="capstone_files/libs/quarto-html/popper.min.js"></script>
<script src="capstone_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="capstone_files/libs/quarto-html/anchor.min.js"></script>
<link href="capstone_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="capstone_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="capstone_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="capstone_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="capstone_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="capstone_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="capstone_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">


</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Capstone Project: Evaluating AI Accuracy for Telehealth Diagnosis</h1>
            <p class="subtitle lead">Generative AI &amp; Healthcare Diagnoses</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-contents">
               <p>Alaina Holland </p>
               <p>Maile Sakamoto </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#generative-ai-in-healthcare" id="toc-generative-ai-in-healthcare" class="nav-link" data-scroll-target="#generative-ai-in-healthcare">Generative AI in Healthcare</a>
  <ul class="collapse">
  <li><a href="#current-applications" id="toc-current-applications" class="nav-link" data-scroll-target="#current-applications">Current Applications</a></li>
  <li><a href="#benefits-of-generative-ai-in-healthcare" id="toc-benefits-of-generative-ai-in-healthcare" class="nav-link" data-scroll-target="#benefits-of-generative-ai-in-healthcare">Benefits of Generative AI in Healthcare</a></li>
  <li><a href="#challenges-of-generative-ai-in-healthcare" id="toc-challenges-of-generative-ai-in-healthcare" class="nav-link" data-scroll-target="#challenges-of-generative-ai-in-healthcare">Challenges of Generative AI in Healthcare</a></li>
  </ul></li>
  <li><a href="#ethical-considerations-and-bias-mitigation" id="toc-ethical-considerations-and-bias-mitigation" class="nav-link" data-scroll-target="#ethical-considerations-and-bias-mitigation">Ethical Considerations and Bias Mitigation</a>
  <ul class="collapse">
  <li><a href="#limitations-of-synthetic-data-in-healthcare-ai-models" id="toc-limitations-of-synthetic-data-in-healthcare-ai-models" class="nav-link" data-scroll-target="#limitations-of-synthetic-data-in-healthcare-ai-models">Limitations of Synthetic Data in Healthcare AI Models</a></li>
  </ul></li>
  <li><a href="#conclusion-of-background" id="toc-conclusion-of-background" class="nav-link" data-scroll-target="#conclusion-of-background">Conclusion of Background</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#dataset-selection-and-api-development" id="toc-dataset-selection-and-api-development" class="nav-link" data-scroll-target="#dataset-selection-and-api-development">Dataset Selection and API Development</a></li>
  <li><a href="#data-engineering" id="toc-data-engineering" class="nav-link" data-scroll-target="#data-engineering">Data Engineering</a>
  <ul class="collapse">
  <li><a href="#data-collection" id="toc-data-collection" class="nav-link" data-scroll-target="#data-collection">Data Collection</a></li>
  <li><a href="#api-key-setup" id="toc-api-key-setup" class="nav-link" data-scroll-target="#api-key-setup">API Key Setup</a></li>
  <li><a href="#model-selection" id="toc-model-selection" class="nav-link" data-scroll-target="#model-selection">Model Selection</a></li>
  <li><a href="#initial-diagnosis-call" id="toc-initial-diagnosis-call" class="nav-link" data-scroll-target="#initial-diagnosis-call">Initial Diagnosis Call</a></li>
  <li><a href="#accuracy-evaluation" id="toc-accuracy-evaluation" class="nav-link" data-scroll-target="#accuracy-evaluation">Accuracy Evaluation</a></li>
  <li><a href="#medical-family-determination" id="toc-medical-family-determination" class="nav-link" data-scroll-target="#medical-family-determination">Medical Family Determination</a></li>
  <li><a href="#new-feature-creation" id="toc-new-feature-creation" class="nav-link" data-scroll-target="#new-feature-creation">New Feature Creation</a></li>
  <li><a href="#data-cleaning" id="toc-data-cleaning" class="nav-link" data-scroll-target="#data-cleaning">Data Cleaning</a></li>
  <li><a href="#data-storage" id="toc-data-storage" class="nav-link" data-scroll-target="#data-storage">Data Storage</a></li>
  <li><a href="#repository-structure-and-purpose" id="toc-repository-structure-and-purpose" class="nav-link" data-scroll-target="#repository-structure-and-purpose">Repository Structure and Purpose</a></li>
  <li><a href="#entity-relationship-diagram-erd" id="toc-entity-relationship-diagram-erd" class="nav-link" data-scroll-target="#entity-relationship-diagram-erd">Entity-Relationship Diagram (ERD)</a></li>
  </ul></li>
  <li><a href="#statistical-methodology" id="toc-statistical-methodology" class="nav-link" data-scroll-target="#statistical-methodology">Statistical Methodology</a></li>
  <li><a href="#machine-learning" id="toc-machine-learning" class="nav-link" data-scroll-target="#machine-learning">Machine Learning</a></li>
  </ul></li>
  <li><a href="#model-selection-and-development" id="toc-model-selection-and-development" class="nav-link" data-scroll-target="#model-selection-and-development">Model Selection and Development</a></li>
  <li><a href="#addressing-overfitting-and-validation" id="toc-addressing-overfitting-and-validation" class="nav-link" data-scroll-target="#addressing-overfitting-and-validation">Addressing Overfitting and Validation</a></li>
  <li><a href="#model-comparison-and-feature-importance" id="toc-model-comparison-and-feature-importance" class="nav-link" data-scroll-target="#model-comparison-and-feature-importance">Model Comparison and Feature Importance</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a>
  <ul class="collapse">
  <li><a href="#content-breakdown-1" id="toc-content-breakdown-1" class="nav-link" data-scroll-target="#content-breakdown-1">Content Breakdown</a></li>
  <li><a href="#data-augmentation" id="toc-data-augmentation" class="nav-link" data-scroll-target="#data-augmentation">Data Augmentation</a></li>
  <li><a href="#new-feature-creation-1" id="toc-new-feature-creation-1" class="nav-link" data-scroll-target="#new-feature-creation-1">New Feature Creation</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#match-status-analysis" id="toc-match-status-analysis" class="nav-link" data-scroll-target="#match-status-analysis">Match Status Analysis</a></li>
  <li><a href="#note-on-synthetic-data" id="toc-note-on-synthetic-data" class="nav-link" data-scroll-target="#note-on-synthetic-data"><strong>Note on Synthetic Data</strong></a></li>
  </ul></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>One of the most promising developments in this field is generative AI, a subset of artificial intelligence that can create new data based on patterns learned from existing datasets. Generative AI can analyze large volumes of data quickly and identify patterns that may be difficult for human clinicians to discern. This capability holds the potential to revolutionize the diagnostic process, making it faster, more consistent, and potentially more accurate.</p>
<p>Despite its potential, the integration of generative AI into healthcare raises critical questions. Key among these is how the diagnoses generated by AI compare to those made by human clinicians when presented with identical symptoms. Can generative AI achieve the level of accuracy required for clinical use? What are the strengths and limitations of AI in this context?</p>
<p>This capstone project aims to evaluate the diagnostic accuracy of generative AI, specifically ChatGPT, in a telehealth setting. By comparing the AI-generated diagnoses with those provided by human clinicians, we seek to determine the feasibility of using AI for accurate medical diagnoses. Additionally, this study explores the potential impact of generative AI on improving diagnostic processes and patient outcomes.</p>
<p>To achieve these objectives, we developed a methodology involving a dataset licensed from the Massachusetts Institute of Technology (MIT) and sourced from Kaggle, which contains over one hundred symptoms associated with various diagnoses. Using ChatGPT to simulate a telehealth doctor, we employed multiple API calls, presenting it with randomized symptom data and recording its diagnostic predictions. These predictions were then compared to the actual diagnoses in the dataset to assess accuracy.</p>
<p>Our research is structured as follows: We begin with a review of the current state of generative AI in healthcare, highlighting its applications, benefits, and challenges. Next, we describe our methodology in detail, including data collection, model selection, and statistical analysis. We then present our results, followed by a discussion of the implications, limitations, and potential future directions for research. Finally, we summarize our findings and their significance for the future of AI in healthcare.</p>
<p>Through this investigation, we aim to contribute valuable insights into the capabilities and limitations of generative AI in healthcare, paving the way for future advancements and applications in this critical field.</p>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<section id="generative-ai-in-healthcare" class="level2">
<h2 class="anchored" data-anchor-id="generative-ai-in-healthcare">Generative AI in Healthcare</h2>
<p>Generative AI is a branch of artificial intelligence that focuses on creating new data by learning patterns from existing datasets. Unlike traditional AI models that classify or predict based on existing data, generative AI models can generate new, synthetic data that mimics the statistical properties of the training data. This capability has significant implications for various fields, including healthcare, where data generation and pattern recognition are crucial.</p>
<section id="current-applications" class="level3">
<h3 class="anchored" data-anchor-id="current-applications">Current Applications</h3>
<p>Generative AI is already making strides in healthcare through several key applications:</p>
<ul>
<li><p><strong>Clinical Decision-Making:</strong> Generative AI assists in diagnosing diseases, predicting disease progression, triaging patients, and planning treatment. By analyzing vast amounts of patient data, AI can identify patterns and correlations that might be missed by human clinicians.</p></li>
<li><p><strong>Medical Education:</strong> Generative AI contributes to medical education by providing insights into health conditions, generating realistic medical scenarios for training, designing exam questions, and creating interactive learning tools.</p></li>
<li><p><strong>Clinical Documentation:</strong> AI streamlines the documentation process by summarizing patient issues, generating discharge summaries, and creating comprehensive healthcare reports. This reduces the administrative burden on healthcare providers and allows them to focus more on patient care.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./Users/alainaholland/Documents/Github/project-writeup-maile-alaina/images/figure_1.png" class="img-fluid figure-img"></p>
<figcaption><strong>Figure 1: Use Cases of Generative AI in Healthcare.</strong></figcaption>
</figure>
</div>
<p><em>This diagram illustrates various applications of generative AI in healthcare, including drug discovery, disease diagnosis, personalized treatment plans, research, patient care, medical chatbots, predictive maintenance, and medical robots (Uptech Team, n.d.).</em></p></li>
</ul>
</section>
<section id="benefits-of-generative-ai-in-healthcare" class="level3">
<h3 class="anchored" data-anchor-id="benefits-of-generative-ai-in-healthcare">Benefits of Generative AI in Healthcare</h3>
<p>The integration of generative AI into healthcare systems offers several significant benefits:</p>
<ul>
<li><strong>Improved Diagnostic Accuracy:</strong> Generative AI can reduce human error by efficiently analyzing symptoms and identifying potential treatment options, leading to more accurate diagnoses.</li>
<li><strong>Rapid Insights:</strong> AI provides quick access to valuable information, often matching or exceeding the accuracy of specialist recommendations. This can expedite the diagnostic process and improve patient outcomes.</li>
<li><strong>Enhanced Patient Engagement:</strong> By personalizing care and supporting medical research and education, AI enhances patient engagement and satisfaction.</li>
<li><strong>Time and Cost Savings:</strong> AI streamlines processes, reduces the workload for medical professionals and lowers healthcare costs by optimizing resource utilization.</li>
</ul>
</section>
<section id="challenges-of-generative-ai-in-healthcare" class="level3">
<h3 class="anchored" data-anchor-id="challenges-of-generative-ai-in-healthcare">Challenges of Generative AI in Healthcare</h3>
<p>Despite its potential, the adoption of generative AI in healthcare is fraught with challenges: - <strong>Bias and Variability:</strong> AI models can exhibit biases based on their training data, which can affect diagnosis and treatment accuracy. Variability in AI performance across different demographic groups is also a concern. - <strong>Ethical and Privacy Issues:</strong> The use of AI raises ethical questions related to data privacy, informed consent, and the potential for generating inaccurate or biased information. - <strong>Need for Human Oversight:</strong> While AI can assist in diagnostics, human oversight is necessary to verify AI outputs and ensure reliability. Continuous updates and monitoring are required to maintain performance standards.</p>
</section>
</section>
<section id="ethical-considerations-and-bias-mitigation" class="level2">
<h2 class="anchored" data-anchor-id="ethical-considerations-and-bias-mitigation">Ethical Considerations and Bias Mitigation</h2>
<p>The ethical implications of using AI in healthcare are profound. Ensuring data privacy and addressing biases in AI models are paramount:</p>
<ul>
<li><strong>Ensuring Data Quality:</strong> Using comprehensive and representative datasets is crucial to minimize biases and improve the reliability of AI models.</li>
<li><strong>Detecting and Quantifying Biases:</strong> Implementing techniques to identify and quantify biases helps in understanding their impact and developing strategies to mitigate them.</li>
<li><strong>Human Oversight:</strong> Continuous human involvement is essential to verify AI outputs, make critical decisions, and maintain trust in AI systems.</li>
</ul>
<section id="broader-ethical-implications" class="level4">
<h4 class="anchored" data-anchor-id="broader-ethical-implications">Broader Ethical Implications</h4>
<p>Integrating AI into healthcare systems affects not only technical and ethical aspects but also impacts the roles of healthcare professionals and patient trust. Developers and policymakers must ensure that AI enhances patient care without replacing the invaluable human elements of healthcare.</p>
</section>
<section id="limitations-of-synthetic-data-in-healthcare-ai-models" class="level3">
<h3 class="anchored" data-anchor-id="limitations-of-synthetic-data-in-healthcare-ai-models">Limitations of Synthetic Data in Healthcare AI Models</h3>
<p>While synthetic data offers benefits such as privacy compliance and scalability, it has limitations that need to be addressed for effective AI model development:</p>
<ul>
<li><strong>Data Leakage:</strong> Synthetic data may inadvertently incorporate characteristics from the training data, leading to overly optimistic performance evaluations.</li>
<li><strong>Lack of Diversity:</strong> Synthetic data may not accurately represent diverse patient populations, affecting the reliability and generalizability of AI models.</li>
<li><strong>Inherent Biases:</strong> Any biases present in the original training data will be reflected in the synthetic data, potentially exacerbating existing healthcare disparities.</li>
</ul>
</section>
</section>
<section id="conclusion-of-background" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-of-background">Conclusion of Background</h2>
<p>Generative AI holds great promise in transforming healthcare by improving diagnosis, treatment, and patient care. However, realizing this potential requires addressing challenges related to bias, ethics, and data quality. By implementing best practices and maintaining human oversight, we can harness the power of generative AI to enhance the capabilities of healthcare providers, improve patient outcomes, and build a more efficient, accurate, and ethical healthcare system.</p>
</section>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="dataset-selection-and-api-development" class="level2">
<h2 class="anchored" data-anchor-id="dataset-selection-and-api-development">Dataset Selection and API Development</h2>
<p>We started by selecting a dataset licensed from the Massachusetts Institute of Technology (MIT), where each row indicates the presence or absence of over one hundred symptoms associated with a single diagnosis. Using this dataset, we developed multiple API calls utilizing ChatGPT, a popular generative AI platform, to act as a tele-health doctor. For each row in our dataset, the API presented ChatGPT with a randomized order of symptoms that tested positive and requested its diagnosis estimation. Following the API’s execution, we compared ChatGPT’s diagnosis with the diagnosis provided in the source dataset. To assess accuracy, we applied a scoring system: one point for an incorrect and unrelated diagnosis, two points for an incorrect but related diagnosis, and three points for a correct diagnosis. This methodology enabled us to evaluate the effectiveness of ChatGPT in accurately predicting diagnoses based on symptom data.</p>
</section>
<section id="data-engineering" class="level2">
<h2 class="anchored" data-anchor-id="data-engineering">Data Engineering</h2>
<section id="data-collection" class="level3">
<h3 class="anchored" data-anchor-id="data-collection">Data Collection</h3>
<p>Our data collection process involved several stages and sources:</p>
<ul>
<li>Initially, we sourced synthetic symptom and prognosis data from Kaggle, providing a foundational dataset for our project.</li>
<li>We utilized the ChatGPT API to generate additional data by requesting diagnosis estimations.</li>
<li>Alongside the diagnosis estimations, we recorded an accuracy score ranging from 1 to 3 to evaluate ChatGPT’s diagnostic performance. ### Dataset Description <strong>Synthetic Source:</strong> The synthetic dataset was sourced from Kaggle’s “Disease Prediction Using Machine Learning” competition. It contains two primary CSV files for training and testing, with each file containing 133 columns (132 symptom columns and 1 prognosis column).</li>
</ul>
<section id="content-breakdown" class="level4">
<h4 class="anchored" data-anchor-id="content-breakdown">Content Breakdown:</h4>
<ul>
<li><strong>Columns:</strong> 132 columns for symptoms (e.g., itching, skin rash) and 1 column for disease prognosis.</li>
<li><strong>Files:</strong> Training.csv for model training and Testing.csv for model evaluation. ### Data Augmentation To understand the impact of generative AI on prognosis diagnosing, we augmented our data by comparing the accuracy between the initial dataset and generative AI outputs through API calls using OpenAI.</li>
</ul>
</section>
</section>
<section id="api-key-setup" class="level3">
<h3 class="anchored" data-anchor-id="api-key-setup">API Key Setup</h3>
<p>We selected OpenAI for this project because its API allows developers to integrate advanced language features into their applications. OpenAI’s versatility in chatbots, virtual assistants, and content creation made it ideal for simulating a doctor’s role.</p>
</section>
<section id="model-selection" class="level3">
<h3 class="anchored" data-anchor-id="model-selection">Model Selection</h3>
<p>We utilized the “gpt-3.5-turbo” model from OpenAI, known for its efficiency and enhanced capabilities. This model was chosen for its ability to handle complex language tasks with high accuracy.</p>
</section>
<section id="initial-diagnosis-call" class="level3">
<h3 class="anchored" data-anchor-id="initial-diagnosis-call">Initial Diagnosis Call</h3>
<p>Our first API call involved instructing the AI to act as a doctor with the following prompt:</p>
<blockquote class="blockquote">
<p>*“Pretend you are a doctor. Patient presents to you with symptoms: {’ ’.join(symptoms)}.</p>
<p>Predict the primary diagnosis concisely using ten words or less.”*</p>
</blockquote>
</section>
<section id="accuracy-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="accuracy-evaluation">Accuracy Evaluation</h3>
<p>We evaluated the predicted prognosis using a custom function get_rating that sends a prognosis and its predicted values to the GPT-4 API and receives a rating based on match accuracy. The rating scale ranges from 1 to 3:</p>
<ol type="1">
<li>No match</li>
<li>Same family</li>
<li>Perfect match</li>
</ol>
</section>
<section id="medical-family-determination" class="level3">
<h3 class="anchored" data-anchor-id="medical-family-determination">Medical Family Determination</h3>
<p>We determined the medical “family” for both the original prognosis and the generative AI prognosis using specific prompts to categorize them.</p>
</section>
<section id="new-feature-creation" class="level3">
<h3 class="anchored" data-anchor-id="new-feature-creation">New Feature Creation</h3>
<p>Due to the API calls, the following new features (columns) were created:</p>
<ul>
<li>Predicted Values</li>
<li>Rating</li>
<li>Medical Family</li>
<li>Predicted Family</li>
</ul>
<p>We also created new “calculated columns” to determine a match between the original data and the generative AI data, including match_found and match_found_family.</p>
</section>
<section id="data-cleaning" class="level3">
<h3 class="anchored" data-anchor-id="data-cleaning">Data Cleaning</h3>
<p>Data cleaning and preprocessing were essential to ensure the quality and reliability of our dataset. Key steps included:</p>
<ul>
<li>Addressing inconsistencies or errors.</li>
<li>Extracting scales from the “predicted diagnosis” to include only the diagnosis.</li>
<li>Randomizing the order of symptoms to account for replicates.</li>
</ul>
</section>
<section id="data-storage" class="level3">
<h3 class="anchored" data-anchor-id="data-storage">Data Storage</h3>
<p>We utilized a GitHub repository for the effective organization and future reference of our data, enabling efficient version control and centralized access.</p>
</section>
<section id="repository-structure-and-purpose" class="level3">
<h3 class="anchored" data-anchor-id="repository-structure-and-purpose">Repository Structure and Purpose</h3>
<ul>
<li>.github: GitHub-specific configurations.</li>
<li><strong>Data:</strong> Stores raw and processed datasets.</li>
<li><strong>Data_Engineering:</strong> Scripts and resources for data engineering tasks.</li>
<li><strong>Documentation:</strong> Project documentation, reports, and written materials.</li>
<li><strong>Machine_Learning:</strong> Machine learning models, training scripts, and evaluation metrics.</li>
<li><strong>Statistics:</strong> Statisitical modeling, scripts, and evaluation metrics.</li>
<li><strong>.DS_Store:</strong> A system file related to macOS directory management.</li>
<li><strong>README.md:</strong> Overview of the project, research question, project description, and links to additional resources.</li>
</ul>
</section>
<section id="entity-relationship-diagram-erd" class="level3">
<h3 class="anchored" data-anchor-id="entity-relationship-diagram-erd">Entity-Relationship Diagram (ERD)</h3>
<p>Our data is structured in a relational database to maintain a normalized and efficient schema, which is visualized in the following ERD:</p>
</section>
</section>
<section id="statistical-methodology" class="level2">
<h2 class="anchored" data-anchor-id="statistical-methodology">Statistical Methodology</h2>
<p>We employed a comprehensive statistical methodology to evaluate the performance of generative AI (ChatGPT) in diagnosing medical conditions. Our approach included descriptive statistics, accuracy metrics, various statistical tests, error analysis, and bias and variability analysis. Here’s an overview of the statistical methods used:</p>
<ol type="1">
<li><p><strong>Descriptive Statistics:</strong> To summarize the central tendency and dispersion of accuracy scores, we calculated the mean, median, mode, standard deviation, and variance. This provided a foundational understanding of the distribution of diagnostic accuracy ratings.</p></li>
<li><p><strong>Confusion Matrix:</strong> We used a confusion matrix to visualize the AI model’s performance by showing the counts of true positives, true negatives, false positives, and false negatives. This helped in understanding the model’s strengths and weaknesses in classification tasks.</p></li>
<li><p><strong>Accuracy Metrics:</strong> We calculated precision, recall, and F1 scores to evaluate the model’s performance. Precision and recall provided insights into the model’s ability to correctly identify positive cases, while the F1 score balanced these metrics to give an overall performance measure.</p></li>
<li><p><strong>Chi-Square Test:</strong> To determine if there was a significant difference between the expected and observed frequencies of diagnostic accuracy categories, we conducted a chi-square test. This helped us assess the model’s performance consistency across different diagnostic categories.</p></li>
<li><p><strong>Correlation Analysis:</strong> Correlation analysis was performed to assess the relationships between different features in the dataset and the accuracy of AI predictions. This helped us understand the impact of various features on the model’s performance and identify areas for potential improvement.</p></li>
</ol>
<p>By employing these statistical methods, we comprehensively evaluated the AI’s diagnostic capabilities, providing a robust framework for understanding its accuracy, reliability, and areas for future enhancement. This multi-faceted approach ensured a thorough assessment, contributing valuable insights into the feasibility and effectiveness of using generative AI for healthcare diagnostics.</p>
</section>
<section id="machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning">Machine Learning</h2>
</section>
</section>
<section id="model-selection-and-development" class="level1">
<h1>Model Selection and Development</h1>
<p>We developed multiple machine learning models, including logistic regression, decision trees, random forests, support vector machines (SVM), and neural networks to diagnose ailments.</p>
</section>
<section id="addressing-overfitting-and-validation" class="level1">
<h1>Addressing Overfitting and Validation</h1>
<p>To prevent overfitting and ensure generalizability, we implemented k-fold cross-validation and pruning techniques.</p>
</section>
<section id="model-comparison-and-feature-importance" class="level1">
<h1>Model Comparison and Feature Importance</h1>
<p>Comparing different models allowed us to identify the most effective algorithm for diagnosing ailments. Analyzing feature importance in the random forest model provided insights into influential symptoms, guiding further refinement of telehealth diagnosis platforms.</p>
</section>
<section id="data" class="level1">
<h1>Data</h1>
<p>Our first dataset, the synthetic source, was sourced from a Disease Prediction Using Machine Learning on Kaggle.com, a data science competition platform and online community for data scientists and machine learning practitioners. The dataset comprises two primary CSV files—one for training and another for testing. Each file contains 133 columns, with 132 columns representing different symptoms experienced by patients, and the final column denoting the disease prognosis. This structure supports the development of models capable of predicting 42 distinct diseases based on the given symptoms.</p>
<section id="content-breakdown-1" class="level2">
<h2 class="anchored" data-anchor-id="content-breakdown-1">Content Breakdown</h2>
<ul>
<li><strong>Columns</strong>: The dataset includes 133 columns:
<ul>
<li>132 columns representing various symptoms (e.g., itching, skin rash, continuous sneezing, joint pain).</li>
<li>1 column for disease prognosis, indicating the disease corresponding to the symptoms.</li>
</ul></li>
<li><strong>Files</strong>: The dataset comprises two files:
<ul>
<li>Training.csv: Used to train machine learning models.</li>
<li>Testing.csv: Used to evaluate the performance of the trained models.</li>
</ul></li>
</ul>
</section>
<section id="data-augmentation" class="level2">
<h2 class="anchored" data-anchor-id="data-augmentation">Data Augmentation</h2>
<p>To understand how generative AI can impact prognosis diagnosing, we recognized that our original dataset was insufficient. Therefore, we augmented our data by comparing the accuracy between our initial dataset and generative AI outputs. We did this by making a series of API calls using OpenAI, with the AI acting as a virtual doctor.</p>
</section>
<section id="new-feature-creation-1" class="level2">
<h2 class="anchored" data-anchor-id="new-feature-creation-1">New Feature Creation</h2>
<p>As mentioned prior due to the API calls, the following new features (columns) were created they include “Predicted Values”, and “Rating”. Based on these new features, we also created the following new “calculated columns” to determine a match between the original data and the generative AI data. These features include “match_found” and “match_found_family”.</p>
<p>It was done in R by adding a new column to the dataset to check if there are any matching words between the prognosis and predicted values. This helps identify if the predicted prognosis contains any terms that appear in the actual prognosis.</p>
<p>ds2 = ds2 %&gt;% mutate(match_found = mapply(function(x, y) { words1 &lt;- str_split(x, ” “)[[1]] words2 &lt;- str_split(y,” “)[[1]] as.integer(any(words1 %in% words2)) }, prognosis, predicted_values))</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>In our project, we applied statistical thinking by conducting an error analysis and a diagnostic accuracy assessment. These methods allowed us to distill the complex interactions between predictions and actual outcomes into more manageable and interpretable metrics.</p>
<p>We analyzed the discrepancies between the original prognoses and the predictions provided by ChatGPT in an error analysis model. This involved identifying instances where the AI’s prognosis diverged from the original prognosis and categorizing these errors to understand their nature and distribution. This method was appropriate because it helped us identify specific areas where the AI’s predictions were less accurate and provided insights into potential causes of these errors.</p>
<p>We assessed how well ChatGPT’s diagnostic predictions aligned with the original diagnoses by comparing the two sets of prognoses. We used a match scale for this assessment, where 1 indicated no match, 2 indicated a match within the same diagnosis group, and 3 indicated an exact match. This match scale, as mentioned above in our methods, allowed us to quantify the degree of alignment between the AI’s predictions and the original diagnoses. This involved calculating the frequency of each match level and analyzing how often ChatGPT’s predictions aligned with the original diagnoses. This approach was suitable for evaluating the overall performance of the AI in terms of accuracy and relevance.</p>
<p>To better understand the results, we generated visualizations such as bar plots and histograms. These visualizations helped us interpret the distribution of accuracy ratings and errors, providing a clearer picture of the AI’s performance.</p>
<section id="match-status-analysis" class="level3">
<h3 class="anchored" data-anchor-id="match-status-analysis">Match Status Analysis</h3>
<p>In our project, we evaluated the accuracy of ChatGPT’s diagnostic predictions by comparing them to the actual diagnoses. We categorized the predictions into two groups:</p>
<ul>
<li><strong>False</strong>: The diagnoses do not match.</li>
<li><strong>True</strong>: The diagnoses match.</li>
</ul>
<p>To provide an overall picture of ChatGPT’s performance, we visualized the distribution of these match statuses.</p>
<section id="key-findings" class="level4">
<h4 class="anchored" data-anchor-id="key-findings">Key Findings:</h4>
<section id="distribution-of-match-status" class="level5">
<h5 class="anchored" data-anchor-id="distribution-of-match-status">Distribution of Match Status:</h5>
<ul>
<li>Most of the predictions were categorized as <strong>False</strong>.</li>
<li>A smaller proportion of predictions were categorized as <strong>True</strong>.</li>
</ul>
</section>
<section id="visualization" class="level5">
<h5 class="anchored" data-anchor-id="visualization">Visualization:</h5>
<ul>
<li>We used a bar plot to show the counts of <code>False</code> and <code>True</code> match statuses. This visual helps to quickly see the proportion of correct predictions versus incorrect ones.</li>
</ul>
</section>
</section>
<section id="interpretation" class="level4">
<h4 class="anchored" data-anchor-id="interpretation">Interpretation:</h4>
<ul>
<li><strong>False</strong>: This category had a higher count, indicating that ChatGPT’s predictions often did not match the actual diagnoses.</li>
<li><strong>True</strong>: This category had a lower count, showing that fewer predictions were accurate.</li>
</ul>
<p>The bar plot provides a clear picture of how often ChatGPT’s predictions align with the actual diagnoses. This analysis highlights areas where the predictions were accurate and where they were not, helping us understand the strengths and weaknesses of ChatGPT’s diagnostic capabilities. Going forward, we can focus on improving the model to increase the number of accurate predictions, test it on more diverse datasets, and refine the prediction algorithms. ### Summary of Mean Match Score Analysis</p>
<p>In our project, we set out to evaluate the accuracy of ChatGPT’s diagnostic predictions compared to the original diagnoses. We used a match scale to measure how well the AI’s predictions matched the actual outcomes:</p>
<ul>
<li><strong>No Match (1)</strong>: The diagnoses do not match at all.</li>
<li><strong>In the Same Family (2)</strong>: The diagnoses are in the same general category.</li>
<li><strong>Perfect Match (3)</strong>: The diagnoses are identical.</li>
</ul>
<p>To summarize the overall accuracy, we calculated the mean match score, which is the average of all match scores in the dataset.</p>
</section>
<section id="key-findings-1" class="level4">
<h4 class="anchored" data-anchor-id="key-findings-1">Key Findings:</h4>
<ol type="1">
<li><strong>Mean Match Score Calculation</strong>:
<ul>
<li>We computed the mean match score by adding all the match scores together and dividing by the number of data points. For example, with match scores of 3, 2, 1, 3, and 2, the mean match score is ( = 2.2 ).</li>
</ul></li>
<li><strong>Interpretation of the Mean Match Score</strong>:
<ul>
<li>A higher mean score means ChatGPT’s predictions are generally accurate and closely match the original diagnoses.</li>
<li>A lower mean score indicates that the predictions are less accurate and often do not align with the actual diagnoses.</li>
</ul></li>
<li><strong>Visualization</strong>:
<ul>
<li>We created a bar plot to show the distribution of match scores, with a dashed line representing the mean match score. This visual helps to quickly understand the overall accuracy and the frequency of each match level.</li>
</ul></li>
<li><strong>Results</strong>:
<ul>
<li>The analysis showed that ChatGPT’s predictions, on average, are more likely to fall into the same diagnostic category as the original diagnoses rather than being completely off.</li>
</ul></li>
</ol>
<p>The mean match score offers a clear picture of ChatGPT’s diagnostic accuracy. By understanding this metric, we can see how well the AI-based platform performs and identify areas for improvement. Next steps include testing on more diverse datasets, refining the models, and further analyzing key features to boost prediction accuracy. ## Machine Learning</p>
<p>In recent years, machine learning has revolutionized various industries, including healthcare. Machine learning algorithms can analyze vast amounts of data to identify patterns and make predictions, potentially improving diagnosis accuracy and patient outcomes. One area of growing interest is the use of AI-based telehealth platforms, which provide remote medical diagnosis and consultation services. These platforms utilize machine learning models to assist healthcare providers in diagnosing patient ailments based on symptoms reported by patients online.</p>
<p>We wanted to determine how difficult it is to accurately predict prognosis, so we developed our own machine learning model. By creating and testing this model, we aim to better understand the challenges and potential pain points that these AI-based platforms may encounter. Our goal is to provide insights into optimizing their algorithms for more accurate ailment diagnosis.</p>
</section>
<section id="process" class="level4">
<h4 class="anchored" data-anchor-id="process">Process</h4>
</section>
<section id="data-preprocessing" class="level4">
<h4 class="anchored" data-anchor-id="data-preprocessing">Data Preprocessing</h4>
<p>Involves dropping unnecessary columns, encoding categorical variables, and splitting the data into training and testing sets.</p>
<pre><code>
#### Exploratory Data Analysis (EDA)

In this section, we performed various analyses to understand the data better. 


### Results

#### Logistic Regression 

The Logistic Regression model correctly identified 83.57% of the
diagnoses in the test set. This means it made correct predictions for
83.57% of the cases, but there were still some errors.


#### Decision Tree

The Decision Tree model perfectly classified all samples in the test
set, achieving 100% accuracy. This means it correctly identified every
diagnosis without any errors.

</code></pre>
</section>
<section id="k-fold-cross-validation" class="level4">
<h4 class="anchored" data-anchor-id="k-fold-cross-validation">K-Fold Cross-Validation</h4>
<p>To ensure the Decision Tree model’s performance was consistent, we used a technique called 5-fold cross-validation. This process splits the data into five parts, trains the model on four parts, and tests it on the remaining part. The average accuracy was nearly perfect at 99.98%, indicating the model performed exceptionally well across different subsets of the data.</p>
</section>
<section id="pruned-decision" class="level4">
<h4 class="anchored" data-anchor-id="pruned-decision">Pruned Decision</h4>
<p>Tree Pruning was applied to the Decision Tree to simplify it and prevent it from being too specific to the training data. The pruned tree achieved an average accuracy of 93.91%, which is lower than the unpruned tree, suggesting that while pruning reduced complexity, it also slightly decreased accuracy.</p>
</section>
<section id="feature-importance-analysis" class="level4">
<h4 class="anchored" data-anchor-id="feature-importance-analysis">Feature Importance Analysis</h4>
<p>The feature importance analysis of the Random Forest model reveals the top features contributing to the model’s predictions. The top 20 important features are visualized in the provided plot. The most important features in predicting the prognosis are muscle pain, itching, chest pain, and high fever. These features have the highest importance scores, indicating they play a significant role in the model’s decision-making process.</p>
</section>
<section id="random-forest" class="level4">
<h4 class="anchored" data-anchor-id="random-forest">Random Forest</h4>
<p>The Random Forest model, which uses multiple decision trees, also performed very well, with an average accuracy of 99.98%. This model considered various symptoms like muscle pain, itching, chest pain, and high fever as the most important factors in predicting diagnoses.</p>
</section>
<section id="support-vector-machine-svm" class="level4">
<h4 class="anchored" data-anchor-id="support-vector-machine-svm">Support Vector Machine (SVM)</h4>
<p>The SVM model achieved perfect accuracy, consistently making correct predictions across all subsets of the data.</p>
</section>
<section id="neural-network" class="level4">
<h4 class="anchored" data-anchor-id="neural-network">Neural Network</h4>
<p>The Neural Network model also showed near-perfect performance, with an average accuracy of 99.98%.</p>
</section>
<section id="comparison-of-models" class="level4">
<h4 class="anchored" data-anchor-id="comparison-of-models">Comparison of Models</h4>
<p>All three models—Random Forest, SVM, and Neural Network—demonstrated excellent performance with high accuracy and low variability. The SVM model showed perfect accuracy in every test, but the Random Forest and Neural Network models also performed exceptionally well.</p>
</section>
<section id="testing-on-predicted-prognosis" class="level4">
<h4 class="anchored" data-anchor-id="testing-on-predicted-prognosis">Testing on Predicted Prognosis</h4>
<p>We also evaluated the models on new data that included predicted diagnoses. The accuracy results were as follows:</p>
<ul>
<li><p>Random Forest: 98.5%</p></li>
<li><p>SVM: 99.0%</p></li>
<li><p>Neural Network: 98.7%</p></li>
</ul>
</section>
</section>
<section id="note-on-synthetic-data" class="level3">
<h3 class="anchored" data-anchor-id="note-on-synthetic-data"><strong>Note on Synthetic Data</strong></h3>
<p>It’s important to mention that the data used in this project was synthetic, meaning it was artificially generated to simulate real-world scenarios. Because synthetic data can be designed to be clear and unambiguous, models often achieve very high accuracy. Therefore, while the results are promising, they do not fully represent the model’s performance on real-world data, which can be more complex and noisy.</p>
<section id="machine-learning-conclusion" class="level4">
<h4 class="anchored" data-anchor-id="machine-learning-conclusion">Machine Learning Conclusion</h4>
<p>The models developed in this study achieved high accuracy in predicting diagnoses. The SVM model was especially impressive, with perfect accuracy in cross-validation tests. These results suggest that AI-based telehealth diagnosis platforms can be very accurate. However, it’s important to ensure these models don’t overfit to specific data and can generalize well to new cases. Future steps include testing on more diverse datasets, fine-tuning the models, and further analyzing the important features to optimize performance.</p>
</section>
</section>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<p>Our project aimed to assess the performance of generative AI, specifically ChatGPT, in the context of healthcare diagnostics. We evaluated the AI’s diagnostic accuracy and conducted a detailed error analysis to understand its efficacy and limitations.</p>
<p>The results of our analysis indicate that ChatGPT’s diagnostic capabilities show promise but are not yet entirely accurate. Our diagnostic accuracy assessment revealed that while the AI could group symptoms effectively, achieving exact matches with original diagnoses was less frequent. The use of a match scale (1-3) demonstrated that the AI often aligned within the same diagnostic group but often fell short of precise accuracy.</p>
<p>Our analyses highlighted both the strengths and weaknesses of ChatGPT in diagnostic scenarios. While the AI provides valuable insights and can suggest plausible directions for further diagnosis, it does not yet offer the level of accuracy required for definitive diagnostic purposes.</p>
<p>To extend this research, future projects could focus on: 1. <strong>Enhancing Accuracy</strong>: Further development and training of AI models to improve their diagnostic precision. 2. <strong>Broader Data Integration</strong>: Incorporating more diverse and comprehensive datasets to reduce biases and enhance the AI’s generalizability. 3. <strong>Clinical Validation</strong>: Conducting studies in real clinical settings to evaluate the AI’s performance in practical, high-stakes environments.</p>
<p>Alternatively, if these technological advancements do not achieve the desired accuracy, exploring alternative methods or augmenting AI with additional diagnostic tools might be worthwhile. This would ensure that time and resources are invested in avenues that offer the most significant potential for advancing diagnostic capabilities.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>